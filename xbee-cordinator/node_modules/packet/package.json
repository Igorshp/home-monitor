{
  "name": "packet",
  "description": "Pure JavaScript evented binary parsers and serializers for Node.js.",
  "version": "0.0.4",
  "keywords": [
    "packet",
    "pack",
    "binary",
    "network",
    "structure",
    "async",
    "asynchronous",
    "javascript"
  ],
  "author": {
    "name": "Alan Gutierrez",
    "email": "alan@prettyrobots.com"
  },
  "devDependencies": {
    "proof": "0.0.15"
  },
  "scripts": {
    "test": "proof t/*/*.t.js"
  },
  "dependencies": {},
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/bigeasy/packet/raw/master/LICENSE"
    }
  ],
  "homepage": "https://github.com/bigeasy/packet",
  "repository": {
    "type": "git",
    "url": "http://github.com/bigeasy/packet.git"
  },
  "readme": "# Packet [![Build Status](https://secure.travis-ci.org/bigeasy/packet.png?branch=master)](http://travis-ci.org/bigeasy/packet)\n\nAn evented binary packet and structure parser for Node.js.\n\n## Contributors\n\n  * [Ben Hockey](https://github.com/neonstalwart)\n  * [Aaron Qian](https://github.com/aq1018)\n\n## Objectives\n\nNode Packet creates **binary parsers** and **serializers** that are\n**incremental**, **streaming**, and **pausable** through a binary pattern\nlanguage that is **declarative** and very **expressive**.\n\nNode Packet simplifies the construction an maintainence of libraries that\nconvert binary to JavaScript and back. The name Packet may make you think that\nit is designed solely for binary network protocols, but it is also great for\nreading and writing binary file formats.\n\n**Incremental** &mdash; Node packet creates incremental parsers and serailizers\nthat are almost as fast as the parser you'd write by hand, but a lot easier to\ndefine and maintain.\n\n**Declarative** &mdash; Packet defines a binary structure using a pattern\nlanguage inspired by Perl's `pack`. The binary patterns are used to define both\nparsers and serializers. If you have a protocol specification, or even just a C\nheader file with structures that define your binary data, you can probably\ntranslate that directly into Node Packet patterns.\n\nFor parsers, you associate the patterns to callbacks invoked with captured\nvalues when the pattern is extracted from the stream. For serializers you simply\ngive the values to write along with the pattern to follow when writing them.\n\n**Expressive** &mdash; The pattern language can express\n\n  * signed and unsigned integers, \n  * endianess of singed and unsigned integers,\n  * floats and doubles,\n  * fixed length arrays of characters or numbers,\n  * length encoded strings of characters or numbers,\n  * zero terminated strings of characters or numbers,\n  * said strings terminated any fixed length terminator you specify,\n  * padding of said strings with any padding value you specify,\n  * singed and unsigned integers extracted from bit packed integers,\n  * conditions based on bit patterns\n  * character encodings,\n  * custom tranformations,\n  * and pipelines of character encodings and custom tranformations.\n\n**Streaming** &mdash; Node Packet implements the Node.js [stream\ninterface](http://nodejs.org/docs/v0.4.8/api/streams.html) in both the `Parser`\nand the `Serializer`. You can pump a stream into a Packet `Parser` and it will\ninvoke your packet handlers.  \n\n**Pausable** &mdash; The streams implemented by both parsers and serializers\nare pausable. Parsers relay the pause to the source stream, and mark thier spot\nin the buffer they are parsing. Serializers can effectively pause the user code\nthat is feeding the serializer.\n\n### Limitations\n\n**Parsing not searching** &mdash; Packet is not a pattern matching library. It\ndoes not search binary streams for patterns. Packet is used for parsing\nwell-defined streams of binary data.\n\n**8-bit boundaries** &mdash; I'm unable to think of an an example in\ncontemporary computing that doesn't align to an 8-bit boundary, but the world is\nbig and I am small, so I plan on being surprised. I can also imagine that\nsomeone might want to unleash Packet on legacy data someday, from way back when\na byte was whatever a computer maufacturer said it was.\n\nTherefore, It's worth noting that Packet parses 8-bit bytes and expects bytes to\nalign to an 8-bit boundary. Node Packet can parse 7-bit ASCII formats like tar\narchives, because they are 8-bit aligned with the top bit ignored. Packet can\nalso parse and serialize bit packed integers, so it does support awkward integer\nsizes, but within an 8-bit aligned integer.\n\n## Installing\n\nInstall Packet using NPM. The source is available on\n[GitHub](https://github.com/bigeasy/node-packet).\n\n```\nnpm install packet\n```\n\n## Parsers and Serializers\n\nNode Packet defines a binrary format using a binary pattern language inspried by\nPerl's `pack` function. The pattern language is used in a `Parser` to define the\nparameters passed to callback when enough bytes are read from the input stream\nto satisfy the pattern. The pattern language is used in a `Serializer` to define\nhow JavaScript primitives passed to the `serialize` method are written to stream.\n\n### Patterns\n\nPatterns are a series of element declarations joined by commas.\n\n```javascript\nparser.parse(\"b16, b32, b8z\", function (length, address, name) {\n  frobinate(length, address, name);\n});\n```\n\nYou can also name the elements in a pattern. If named, parsers will be able to\npass maps to callbacks, serializers will be able to serialize maps of data.\n\n```javascript\nparser.parse(\"b16 => length, b32 => address, b8z => name\", function (record) {\n  frobinate(record.length, record.address, record.name);\n});\n```\n\nUnnamed elements are good for short, simple patterns. For longer patterns it is\neasier to have parsers build maps for you, and for serializers to pluck the\nright values out of maps.\n\nThe following example shows a complicated pattern, the invariable portion of an\nIP header, the first 20 bytes before options, if any.\n\n```javascript\n// Define an IP header pattern using a joined array to explode the pattern.\nip =\n[ \"b8{b4 => version, b4 => headerLength}\"\n, \"b8   => typeOfService\"\n, \"b16  => length\"\n, \"b16  => identification\"\n, \"b16{b3 => flags, b13 => fragmentOffset}\"\n, \"b8   => timeToLive\"\n, \"b8   => protocol\"\n, \"b16  => checksum\"\n, \"b32  => sourceAddress\"\n, \"b32  => destinationAddress\"\n].join(\", \");\n\n// The pattern is then used to defined parser and serializer actions.\nparser.parse(ip, function (header) {\n  console.log(header);\n});\n```\n\n### Parsers\n\nParsers implement the writable stream interface. First you set a binary pattern\nthat the parser will use to interpret the stream. Then you write a byte stream\ninto the parser and it generates events based on the values it extracts from the\nstream.\n\nThe extracted values are fed to callbacks. Callback are associated with a binary\npattern by passing the pattern and callback to the `extract` method.\n\n```javascript\nfunction parse (writable) {\n  var parser = new Parser();\n  parser.extract(\"b8, b8z|utf8(), b16[4]\", function (flag, name, array) {\n    switch (flag) {\n    case 1:\n      ready(name);\n    case 2:\n      aim(name, array);\n    case 3:\n      fire(name, array);\n    default:\n      throw new Error(\"Invalid stream.\");\n    }\n  });\n  writable.pipe(parser);\n}\n```\n\nYou can gather up your pattern and callback associations and give them\nmeaningful using the `pattern` method. This makes it easier to define the flow\nof the paser. The example above only extracted one pattern, while the example\nbelow shows how you would transition from one extraction to the next.\n\n```javascript\nfunction parse (writable) {\n  var parser = new Parser();\n  parser.pattern(\"command\", \"b8, b8z|utf8(), b16[4]\",\n  function (flag, name, array) {\n    switch (flag) {\n    case 1:\n      ready(name);\n      parser.parse(\"command\");\n    case 2:\n      aim(name, array);\n      parser.parse(\"command\");\n    default:\n      fire(name, array);\n    }\n  });\n  parser.parse(\"command\");\n  writable.pipe(parser);\n}\n```\n\nNote that while parser does implement `EventEmitter`, that is only for the sake\nof the `WritableStream` interface. Extracted values are passed directly to the\ncallbacks associated with the pattern, not though an `EventEmitter` event, so\nthat their is no ambiguity about the pattern applied or the values extracted.\n\nThe parser callback recieves the values either as positioned function arguments\nor as an object. How the callback is invoked is based on the pattern and the\n[arity](http://en.wikipedia.org/wiki/Arity) of the callback function.\n\nIn the examples above, callbacks are invoked with positioned arguments. The\nvalues extracted are passed to the callback as arguments in the order in which\nthey were extracted from the stream.\n\nTo receive an object in the callback, we defined named elements. When the\npattern has at least one named element, and the callback has only a single\nargument, an object is passed to the callback containing the values using the\nelement names as keys.\n\n```javascript\nfunction parse (writable) {\n  var parser = new Parser();\n  parser.pattern(\"command\", \"b8 => flag, b8z|utf8() => name, b16[4] => array\",\n  function (command) {\n    switch (command.flag) {\n    case 1:\n      ready(command.name);\n      parser.parse(\"command\");\n    case 2:\n      aim(command.name, command.array);\n      parser.parse(\"command\");\n    default:\n      fire(command.name, command.array);\n    }\n  });\n  parser.parse(\"command\");\n  writable.pipe(parser);\n}\n```\n\nUnnamed elements are excluded, but there's no good reason not name them. Use a\nskip pattern to skip over unwanted bytes instead.\n\nYou can still get positioned arguments using a named pattern. Just provide a\ncallback with more than one argument and it will be invoked with the extract\nvalues as parameters.\n\n```javascript\nfunction parse (writable) {\n  var parser = new Parser();\n  parser.pattern(\"command\", \"b8 => flag, b8z|utf8() => name, b16[4] => array\",\n  function (foo, bar, baz) { // Ignore named elements, ask for parameters.\n    switch (foo) {\n    case 1:\n      ready(bar);\n      parser.parse(\"command\");\n    case 2:\n      aim(bar, baz);\n      parser.parse(\"command\");\n    default:\n      fire(bar, baz);\n    }\n  });\n  parser.parse(\"command\");\n  writable.pipe(parser);\n}\n```\n\nA callback for a pattern without any named elements is always invoked with\nvalues as parameters regardless of arity.\n\n## Binary Pattern Fields\n\nThe binary pattern language is used to specify the fields binary structures in\ndata streams, using a comma separated field pattern.\n\n### Big-Endian Byte Ordering\n\nTo define a big-endian byte ordering for a field, prefix the bit size with `b`.\n\n**Mnemonic**: The letter `b` stands for big-endian.\n\n```javascript\n\"b16\"             // Big-endian 32 bit number.\n\"b8\"              // Endianess of a single byte is irrelevant.\n\"l16, b8\"         // Big-endian 16 bit integer followed by a byte.\n```\n\n### Little-Endian Byte Ordering\n\nTo define a little-endian byte ordering for a field, prefix the bit size with `l`.\n\n**Mnemonic**: The letter `l` stands for little-endian.\n\n```javascript\n\"l32\"             // Little-endian 32 bit integer.\n\"l8\"              // Endianess of a single byte is irrelevant.\n\"l16, b8\"         // Little endian 16 bit integer followed by a byte.\n```\n\n### Skipping Bytes\n\nYou can skip over bytes your pattern with `x`.\n\n**Mnemonic**: The letter `x` means to cross-out, which is kind of like skipping.\n\n```javascript\n\"b8, x16, l16\"    // A byte, two skipped bytes, and a little-endian 16 bit\n                  // integer.\n```\n\n### Signed Versus Unsigned Integers\n\nAll numbers are assumed to be unsigned, unless prefixed by a negative symbol.\n\n**Mnemonic**: The `-` symbol indicates the possiblity of negative numbers.\n\n```javascript\n\"-b32\"            // Big-endian 32 bit signed integer.\n\"-l32\"            // Little-endian 32 bit signed integer.\n\"b32\"             // Big-endian 32 bit unsigned integer.\n```\n\n### IEEE 754 Floating Point Numbers\n\nThe number type for JavaScript is the  64 bit IEEE 754 floating point. Node\nPacket can read write 64 bit and 32 bit IEEE 754 floating point numbers.\n\nTo indicated that the type is a floating point number, use the `f` type suffix.\nThis is indicated with a `f` suffix.\n\n**Mnemonic**: The letter `f` stands for\n*floating-point*.\n\n```javascript\n\"b64f\"            // Big-endian 64 bit IEEE 754 double floating point number.\n\"l32f\"            // Little-endian 32 bit IEEE 754 single floating point number.\n```\n\nThe floating-point numbers can be stored in little-endian or big-endian byte order.\n\n### Arrays of Raw Bytes\n\nA value will be converted to a big-endian array of bytes if followed by an `a`\nsuffix.\n\n**Mnemonic**: The letter `a` stands for *array*.\n\n```javascript\n\"l128a\"           // Unsigned little-endian 128 bit integer as big-endian array\n                  // of bytes.\n```\n\nNote that big-endian means that the most signifcant byte is at index `0` of the\narray.\n\nThis can be surprising if you're expecting the the significance of the bytes\nwill increase with the index of the array, but then that's what little-endian is\nall about. (Big-endian orders like Arabic numerals, while little-endian orders\nlike offsets into memory.)\n\nIf you'd prefer a little-endian array, simply call `reverse` on the array passed\nto you.\n\n### Arrays of Common Types\n\nIt is often the case that a binary format contains an array of values. The most\ncommon case are arrays of bytes represnting ASCII or UTF-8 strings.\n\nArrays are specified with an subscript and a count.\n\n**Mnemonic**: The square brackets are used as array subscripts in JavaScript,\nand used to declare array length in other C dialect languages.\n\n```javascript\n\"b32[4]\"          // An array of four big-endian 32 bit numbers.\n\"b8[16]\"          // An array of 16 bytes.\n```\n\nThe array notation produces an array of the type before the subscript.\n\n### Zero Terminated Arrays\n\nZero terminated series are speified with a `z` qualifier.\n\nYou can specify both terminiation and width together. Why would you need this?\nThis occurs in underlying C structures when there is a fixed width character\narray in a structure, but the structure still contains a zero terminated string.\n\n**Upcoming**: Chose your own terminator.\n\n**Mnemonic**: The letter `z` stands for zero.\n\n```javascript\n\"l16z\"            // Little-endian 16 bit numbers terminated by a zero value.\n\"b8z\"             // Byte string terminated by zero.\n\"b8[12]z\"         // Byte string terminated by zero in a field 12 bytes long.\n```\n\n### Array Padding\n\nYou can specify a padding value immediately after the array brackets using curly\nbraces. This should be the numeric value, or character code for padding. If you\nwant to zero pad, use `0`. If you want to pad with ASCII spaces use `32`.\n\n**Mnemonic**: Curly braces are used to define array literals in C.\n\n```javascript\n\"b16[12]{0}\"      // Array of 12 big-endian 16 bit integers, zero padded.\n\"b8[12]{32}z\"     // Byte string terminated by zero in a field 12 bytes long\n                  // ascii space padded.\n```\n### Length Encoded Arrays\n\nLength encoded arrays are specified by joining a count type and a value type\nwith a forward slash character `/`.\n\n**Mnemonic**: Inspired by Perl's `pack`, which uses the slash to separate count\nand type.\n\n```javascript\n\"b8/b8\"           // Length encoded byte array with a byte length.\n\"l16/b8\"          // Length encoded byte array with 16 bit little-endian length.\n```\n\n### Bit Packed Integers\n\nIntegers are often divided into smaller integers through a process called bit\npacking. Bit packing is specified by following an integer specification with \na curly brace enclosed series series of integers patterns whose total size in\nbits equals the size of the packed integer.\n\nPacked integers are always big-endian and can be either singed or unsigned.\n\n**Mnemonic** Curly braces are used to define structures in C and bit packing is\nkind of like a structure.\n\n```javascript\n\"b16{b3,x6,-b7}\"  // A 16 bit big-endian integer divided into a 3-bit integer,\n                  // 6 skipped bits, and a signed 7-bit integer. \n```\n\nYou can also name the packed fields.\n\n```javascript\n\"b16{b3 => type, x6, -b7 => count}\"\n```\n\n### Alternate Patterns\n\nA common pattern in binary formats is using the value of a byte, or the high\norder bits of a byte to specify the type of data to follow. [Length Encoded\nArrays](#length-encoded-arrays) are one example of this practice, where a\nan integer count indicates the length of a following string or array.\n\nWith an alternate pattern, **Packet** will extract an integer from the byte\nstream, then choose a pattern based on the value of that integer. The pattern is\napplied at the index where the integer used to choose the pattern was extracted.\nThat is, the bytes used to choose the pattern are included when the pattern is\napplied. It is a peek and switch.\n\nAlternate patterns are grouped by parenthesis `(` and `)` and delimited by pipes\n`|`. Each alternative maps a match to a pattern separated by a colon `:`.\n\n**Mnemonic** &mdash; Parenthesis and pipes are used to indicate alternation in\nregular expressions, while colons are used to delineate switch options in C.\n\n```javascript\n// MySQL length coded binary; if the byte is less than 252, use the byte value,\n// otherwise the byte value indicates the length of the following word. \n\"b8(0-251: b8 | 252: x8, b16 | 253: x8, b24 | 254: x8, b64)\"\n```\n\nConditions are either a value to match exactly or a range of values. **Packet**\ntests each condition is tested in order. **Packet** uses the alternation of the\nfirst condition to match the extracted integer is used. An alternate without a\ncondition will always match. This is used to specify a default pattern.\n\n```javascript\n// Simpiler, but will also match 255 which is invalid, which is fine if you test\n// the value in your callback.\n\"b8(252: x8, b16 | 253: x8, b24 | 254: x8, b64 | b8)\"\n```\n\nThe values can be expressed in binary, decimal or hexadecimal.\n\n### Bitwise Alternate Patterns\n\nYou can also indicate a branch based on set bits by prefixing the value with an\nampersand. **Packet** will use the value as a bit mask. If the result of a\nlogical *and* with the bit mask equals the bit mask, then **Packet** use use\nthat alternative.\n\n**Mnemonic** The `&` performs a logical and in C and is used to check to see if\nbits in a bit mask are set.\n\n```javascript\n\"b8(&0x80: b16{x1,b15} | b8)\"   // A 15-bit word if the first bit is set,\n                                // otherwise a byte.\n```\n\nBitwise conditions cannot be used in to choose a pattern for serialization. Upon\nserialization, the field value is a JavaScript number, not an stream of bytes.\nThe bit flag simply does not exist.\n\nInstead, we need to perform a range check to determine which pattern. To delimit\nalternate tests for reading and writing, we use a slash in the condition.\n\n```javascript\n// A 15-bit word if the first bit is set, otherwise a byte.\n\"b8(&0x80/0x80-0xffff: b16{x1{1},b15} | b8)\"\n```\n\n### Multi-Field Alternate Patterns\n\nAlternate patterns can define either a single field or multiple field.\nAlternate patterns can contain bit-packed patterns, but they cannot contain\nstill more alternate patterns.\n\n```javascript\n// Two alternate patterns with a different number of fields.\n\"b8(&0x80/1: b16{b1, b15}, b16|b32{b1, b31})\"\n```\n\nIn the above example, the serialization test would be applied to the field value\nin the position of the `b1` field for either alternate.\n\n### Named Alternate Patterns\n\nNames can be applied either to the entire alternation if the alternation\nproduces a single field, or else to individual members of the alternate\npatterns.\n\n```\n// A single field mapped to a name.\n\"b8(&0x80/0x80-0xffff: b16{x1{1},b15} | b8) => number\"\n```\n\nWhen serializing named multi-field patterns, for each alternate, **Packet** will\nuse the first value of the property in the alternate for the serialization\ncondition. **Packet** reads the property from the object we're serializing. If\nthe value is not null, it is tested against the serialization condition. If it\nis null, the test is skipped. We use the first alternate whose object property\nis not null and whose serialization condition matches the object property.\n\n```javascript\n// Multi-field alternates mapped to names.\n\"b8(&0x80/1: b16{b1 => control, b15 => type}, x16|b32{b1 => control, b31 => sequence})\"\n```\n\n### Transforms\n\nOften there are transformations that you need to perform on an field to get\nit to its final state. You may need to convert a byte array to string of a\nparticular character encoding, for example. This is done with a tranformation\nfunctions which are specified with a transformation pipeline.\n\nIf the transformation is a fixed transformation, you can perform the\ntransformation by defining a pipeline. A pipeline defines one or more\ntranformations that are invoked on the value after parsing and before\nserialization. The transformations can accept scalar JavaScript parameters.\n\n```javascript\nfunction str(encoding, name, field, parsing, value) {\n    if (parsing) {\n        var buffer = new Buffer(array.length)\n        for (var i = 0; i < value.length; i++) {\n            buffer[i] = value[i];\n        }\n        var length = value.length\n        if (field.terminator) {\n            length += field.terminator.length;\n        }\n        reutrn buffer.toString(encoding, 0, length);\n    } else {\n        if (field.terminator) {\n            value += field.terminator;\n        }\n        return new Buffer(value, encoding);\n    }\n}\n```\n\nNow you can use the transform in your pattern.\n\n```javascript\n\"n8z|str('ascii')\"      // An ascii string terminated by zero.\n\"n8z|str('ascii'), b16\" // An ascii string terminated by zero followed by a\n                        // big-endian 16 bit integer.\n```\n\nThe `str` transform is defined by default. The transform names are purposely\nterse to fit with the brevity of the pattern language.\n\n## Error Messages\n\nError messages for pattern parsing.\n\n * **invalid pattern at N** &mdash; The characters starting at the specified\n   index is unexpected the pattern is invalid. The invalid character may not be\n   at the specified index, but shortly there after, such as unmatched braces.\n * **bit field overflow at N** &mdash; The the sum of the bit size of bit field\n   elements is greater than the size of the containing element. The sum of the\n   bit size of bit field elements must equal the size of the containing element.\n * **bit field underflow at N** &mdash; The the sum of the bit size of bit field\n   elements is less than the size of the containing element. The sum of the bit\n   size of bit field elements must equal the size of the containing element.\n * **bit size must be non-zero at N** &mdash; Encountered element with a bit size of\n   zero. Element size must be a non-zero value.\n * **bits must be divisible by 8 at N** &mdash; Encountered element with a bit\n   size that is not divisible by 8. If an element is not a bit field element, it\n   must align to an 8-bit boundary.\n * **floats can only be 32 or 64 bits at N** &mdash; Encountered a float element\n   with an unsupported bit size. Only 32 and 64 bit floats are supported.\n * **\"array length must be non-zero at N** &mdash; Encountered an array length\n   of zero. Arrays must have a non-zero length.\n\n### API\n\n@ packet\n\nNode Packet exports the ec2 namespace, which provides the {{Structure}},\n{{Parser}} and {{Serializer}} classes.\n\n~ new Structure(pattern)\n\n  ~ pattern\n\n  The packet pattern.\n\nA structure is an object that both reads from and writes to a buffer\nsyncrhonously. When reading, buffer must contain the entire contents of the\nstructure. When writing, the buffer must have enough space to accomdoate the\nstructure.\n\n~ read(buffer, offset, callback)\n\n  ~ buffer    - The byte buffer.\n  ~ offset?   - The optional offset into the byte buffer. Defaults to `0`.\n  ~ callback  - Called with the parameters read from the byte buffer.\n\nThe read method accepts a buffer with an optional offset. The number of\narguments is determined by the structure packet pattern, and must match\nthe number of arguments expected by the packet pattern.\n\nThe callback will be called with the fields read from the buffer, with the\nactual count of bytes read as the last parameter.\n\n~ write(buffer, offset, value...)\n\n  ~ buffer    - The byte buffer.\n  ~ offset?   - The optional offset into the byte buffer. Defaults to `0`.\n  ~ value...  - The values of the structure.\n\nWrite the arguments to the  buffer at the optional offset. The arguments are\ndetermined by the structure bit pattern. Returns the number of bytes written.\n\n~ sizeOf(value...)\n\n  ~ value...  - The values of the structure.\n\nGet the size of the structure for the given variable length values. A structure\ncan have 0 or more variable length values.\n\nThe `sizeOf` method does not expect and will not correctly calculate the size of\nthe structure if fixed size value are given.\n\n~ new Parser()\n\nParses a buffer and emits events based on patterns.\n\n~ packet(name, pattern, callback)\n\n  ~ name - The name of the packet type.\n  ~ pattern - The packet pattern.\n  ~ callback? - Called when a packet of this type has been read from a buffer.\n\nDefines a named packet type optionally assigning a default response for the\npacket type.\n\nfunction: parse\n\n  parameter: nameOrPattern\n\n  Either the name of a named packet or a one off \n\nfunction: clone\n\nClone the packet parser to create a packet parser that shares the named packet\ndefinitions but has its own parser state.\n\nThis allows a packet parser prototype to be used to efficently create initialized\ninstances.\n\nclass: Serializer\n\n## Change Log\n\nChanges for each release.\n\n### Version 0.0.4\n\nReleased: Mon Nov  6 04:50:16 UTC 2012.\n\n * Create parsers and serializers from prototypes. #53.\n * Parse patterns with Win32 CRLF. #51. (Greg Ose <greg@nullmethod.com>)\n * Copy cached pattern for alternation rewriting. #50.\n * Flatten alternation prior to serialization. #34.\n * Add `.js` suffix to tests. #49.\n * Convert to closure style. #40, #47, #39, #38, #27.\n * Remove pausing from `Parser`. #46.\n * Implement `reset` for serializer. #43.\n * Single letter field names. #45.\n * Remove streams from API. #41.\n\n### Version 0.0.3\n\nReleased: Fri Aug 17 00:40:37 UTC 2012.\n\n * Fix Packet in NPM. #12.\n * Serialize alternate structures. #31.\n * Test serialization of words. #20.\n * Serializer not exported by `index.js`.\n * Named patterns reset buffer offset. #29.\n * Allow spaces before alternation condition. #28.\n * Create a markdown `README.md`. #18.\n * Build on Node 0.8 at Travis CI. #23.\n * Fix too greedy match of bit packing pattern. #19.\n * Skip leading whitespace in pattern. #15.\n",
  "_id": "packet@0.0.4",
  "dist": {
    "shasum": "b53c9add0475a83371ef7538ab6d6e6ac1defae3"
  },
  "_from": "packet"
}
